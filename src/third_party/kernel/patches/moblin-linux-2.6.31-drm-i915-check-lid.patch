diff --git a/drivers/gpu/drm/i915/intel_lvds.c b/drivers/gpu/drm/i915/intel_lvds.c
index 53cccfa..608b7e1 100644
--- a/drivers/gpu/drm/i915/intel_lvds.c
+++ b/drivers/gpu/drm/i915/intel_lvds.c
@@ -36,6 +36,7 @@
 #include "intel_drv.h"
 #include "i915_drm.h"
 #include "i915_drv.h"
+#include <linux/acpi.h>
 
 /**
  * Sets the backlight level.
@@ -425,7 +426,74 @@ static const struct dmi_system_id intel_no_lvds[] = {
 
 	{ }	/* terminating entry */
 };
+#ifdef CONFIG_ACPI
+/*
+ * check_lid_device -- check whether it is ACPI LID device.
+ * @handle: ACPI device handle
+ * @level : depth in the ACPI namespace tree
+ * @context: the number of LID device when we find the device
+ * @rv: a return value to fill if desired (Not use)
+ *
+ * check whether it is a LID device by comparing the HID. If it is,
+ * increase the number of LID device.
+ */
+static acpi_status
+check_lid_device(acpi_handle handle, u32 level, void *context,
+			void **retyurn_value)
+{
+#define		ACPI_HID_LID		"PNP0C0D"
+	struct acpi_device *acpi_dev;
+	int *p_lid = (int *)context;
+
+	acpi_dev = NULL;
+	/* Get the acpi device for device handle */
+	if (acpi_bus_get_device(handle, &acpi_dev) || !acpi_dev) {
+		/* If there is no ACPI device for handle, return */
+		return AE_OK;
+	}
+	if (!strncmp(acpi_device_hid(acpi_dev), ACPI_HID_LID, 7)) {
+		/*
+		 * compare the device HID with "PNP0C0D". If it is equal, the
+		 * LID device is found. Increase the count
+		 */
+		(*p_lid)++;
+	}
+	return AE_OK;
+}
+/**
+ * check whether there exists the ACPI LID device by enumerating the ACPI
+ * device tree.
+ * If ACPI is disabled, there is no ACPI device tree. one is returned.
+ * If the LID device is found, it will return one.
+ * If no LID device is found, it will return  zero.
+ */
+static int intel_lid_present(void)
+{
+	int lid_count = 0;
+
+	if (acpi_disabled) {
+		/*
+		 * if ACPI is disabled, there is no ACPI device tree. And
+		 * we don't know whether there exists the LID device.
+		 * In such case we will return 1.
+		 */
+		return 1;
+	}
+
+	acpi_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,
+				ACPI_UINT32_MAX,
+				check_lid_device, &lid_count, NULL);
+
+	if (!lid_count) {
+		/* No LID device is not found. Return zero */
+		return 0;
+	}
 
+	return 1;
+}
+#else
+static inline int intel_lid_present(void) { return 1; }
+#endif
 /**
  * intel_lvds_init - setup LVDS connectors on this device
  * @dev: drm device
@@ -448,6 +516,17 @@ void intel_lvds_init(struct drm_device *dev)
 	if (dmi_check_system(intel_no_lvds))
 		return;
 
+	if (!intel_lid_present()) {
+		/* If there is no LID device, we can think that there is
+		 * no LVDS output device. In such case it is unnecessary to
+		 * create the LVDS output device.
+		 * But maybe on some boxes there is no LVDS device while the
+		 * LID device is found. If so, it had better be added to
+		 * the quirk list.
+		 */
+		return;
+	}
+
 	intel_output = kzalloc(sizeof(struct intel_output), GFP_KERNEL);
 	if (!intel_output) {
 		return;
